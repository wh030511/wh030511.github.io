<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>工程实战 | Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="Go语言 去字节实习啦！但是要学习Go语言。记录自己学习Golang的过程。">
<meta property="og:type" content="article">
<meta property="og:title" content="工程实战">
<meta property="og:url" content="http://example.com/2020/07/18/Go%E8%AF%AD%E8%A8%80/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="Go语言 去字节实习啦！但是要学习Go语言。记录自己学习Golang的过程。">
<meta property="og:locale" content="en_US">
<meta property="article:published_time" content="2020-07-18T10:00:10.408Z">
<meta property="article:modified_time" content="2020-07-18T10:00:10.408Z">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  
<link rel="stylesheet" href="/css/style.css">

<meta name="generator" content="Hexo 5.2.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-Go语言" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/07/18/Go%E8%AF%AD%E8%A8%80/" class="article-date">
  <time datetime="2020-07-18T10:00:10.408Z" itemprop="datePublished">2020-07-18</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      工程实战
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="Go语言"><a href="#Go语言" class="headerlink" title="Go语言"></a>Go语言</h1><blockquote>
<p>去字节实习啦！但是要学习Go语言。记录自己学习Golang的过程。</p>
</blockquote>
<a id="more"></a>

<h2 id="一、环境配置"><a href="#一、环境配置" class="headerlink" title="一、环境配置"></a>一、环境配置</h2><p><strong>1. 下载Go</strong></p>
<p>windows环境下在官网下载<code>go1.4.windows-amd64.msi</code>安装包，默认将Go安装在<code>C:\Go</code>目录中，其文件目录及解释如下所示</p>
<table>
<thead>
<tr>
<th align="center">文件夹</th>
<th align="center">含义</th>
</tr>
</thead>
<tbody><tr>
<td align="center">api</td>
<td align="center">存放Go API检查器的辅助文件</td>
</tr>
<tr>
<td align="center">bin</td>
<td align="center">存放官方提供的Go语言相关工具的可执行程序。默认是go和gofmt</td>
</tr>
<tr>
<td align="center">doc</td>
<td align="center">存放Go语言几乎全部的HTML格式的官方文档和说明，方便开发者在离线时查看</td>
</tr>
<tr>
<td align="center">misc</td>
<td align="center">存放各类编辑器或IDE软件的插件，辅助查看和编写Go代码</td>
</tr>
<tr>
<td align="center">pkg</td>
<td align="center">用于在构建安装后，保存Go语言标准库的所有归档文件</td>
</tr>
<tr>
<td align="center">src</td>
<td align="center">存放所有标准库、Go语言工具，以及相关底层库的源码</td>
</tr>
<tr>
<td align="center">test</td>
<td align="center">存放测试Go语言自身代码的文件</td>
</tr>
<tr>
<td align="center">lib</td>
<td align="center">存放外部库</td>
</tr>
</tbody></table>
<p>一个.go程序在经过编译后成为.exe文件，直接执行。可以通过go build来编译。也可以通过go run编译并执行，区别是go build 会经历一个打包成exe的过程，而go run不会。实际开发中，一般都要先打包成exe以供使用。</p>
<p><strong>2. 下载集成开发工具goland</strong></p>
<p>jetbrains官网<code>https://www.jetbrains.com/</code>下载msi，安装即可。</p>
<h2 id="二、基本语法"><a href="#二、基本语法" class="headerlink" title="二、基本语法"></a>二、基本语法</h2><h4 id="Ⅰ、变量与运算符"><a href="#Ⅰ、变量与运算符" class="headerlink" title="Ⅰ、变量与运算符"></a>Ⅰ、变量与运算符</h4><h6 id="1-基本数据类型"><a href="#1-基本数据类型" class="headerlink" title="1. 基本数据类型"></a><strong>1. 基本数据类型</strong></h6><table>
<thead>
<tr>
<th align="center">数据类型</th>
<th align="center">类型表示</th>
</tr>
</thead>
<tbody><tr>
<td align="center">有符号整数</td>
<td align="center">int(8/16/32/64)，其中int是根据CPU是32位还是64位决定大小</td>
</tr>
<tr>
<td align="center">无符号整数</td>
<td align="center">uint(8/16/32/64)，其中uint是根据CPU是32位还是64位决定大小</td>
</tr>
<tr>
<td align="center">指针</td>
<td align="center">uintptr（32位平台4字节，64位平台8字节）</td>
</tr>
<tr>
<td align="center">浮点数</td>
<td align="center">float32 float64</td>
</tr>
<tr>
<td align="center">常量</td>
<td align="center">const，常量表达式将在编译期计算，可以是字符、字符串、布尔或者数值</td>
</tr>
<tr>
<td align="center">字符串</td>
<td align="center">string</td>
</tr>
<tr>
<td align="center">复数</td>
<td align="center">complex64（实部虚部都是float32） complex128（实部虚部都是float64）</td>
</tr>
</tbody></table>
<p>数据类型的零值</p>
<table>
<thead>
<tr>
<th align="center">数据类型</th>
<th align="center">零值</th>
</tr>
</thead>
<tbody><tr>
<td align="center">数值类型</td>
<td align="center">0</td>
</tr>
<tr>
<td align="center">布尔类型</td>
<td align="center">false</td>
</tr>
<tr>
<td align="center">字符串</td>
<td align="center">“”（空串）</td>
</tr>
</tbody></table>
<p><strong>注1：</strong></p>
<ol>
<li>uint8 = byte             int32 = rune（表示一个Unicode码点）</li>
<li>浮点数不能直接比较大小，需要先定义一个精度，然后使用math函数的Dim方法与精度比较</li>
<li>常量不能使用<code>:=</code>语法指定</li>
</ol>
<p><strong>注2：</strong></p>
<ol>
<li>被转换的数字值，即传递了一个副本，该数字本身的数据类型不变</li>
<li>将大范围的数字转为小范围的数字时，不会报错，按溢出处理</li>
</ol>
<h6 id="2-基本数据类型转string"><a href="#2-基本数据类型转string" class="headerlink" title="2. 基本数据类型转string"></a><strong>2. 基本数据类型转string</strong></h6><p><strong>基本数据类型转string</strong></p>
<p><strong>方式1</strong>：<code> fmt.Sprintf(&quot;%参数&quot; ， 表达式)</code></p>
<p>参数和表达式的数据类型相匹配</p>
<p>结果返回转换后的字符串</p>
<p><strong>方式2：</strong>使用<code>strconv</code>包的函数</p>
<table>
<thead>
<tr>
<th align="center">函数</th>
<th align="center">功能</th>
</tr>
</thead>
<tbody><tr>
<td align="center">func FomatBool(b bool)</td>
<td align="center">布尔转字符</td>
</tr>
<tr>
<td align="center">func FormatFloat(f float64, fmt byte, prec, bitSize int)</td>
<td align="center">浮点数转字符串，fmt表示格式，prec表示精度，biteSize表示对来源数进行转换</td>
</tr>
<tr>
<td align="center">func FormatInt（num int64 ，base int）</td>
<td align="center">整数转成base进制的字符串</td>
</tr>
<tr>
<td align="center">func FormatUint(i uint64, base int)</td>
<td align="center">无符号整数转为base进制的字符串</td>
</tr>
<tr>
<td align="center">func Itoa（num int）</td>
<td align="center">数字转字符串</td>
</tr>
</tbody></table>
<h6 id="3-string转基本数据类型"><a href="#3-string转基本数据类型" class="headerlink" title="3. string转基本数据类型"></a>3. string转基本数据类型</h6><p><strong>方式1：</strong>使用<code>strconv</code>包的函数</p>
<table>
<thead>
<tr>
<th align="center">函数</th>
<th align="center">功能</th>
</tr>
</thead>
<tbody><tr>
<td align="center">func ParseBool(str string)</td>
<td align="center">字符串转布尔</td>
</tr>
<tr>
<td align="center">func ParseFloat(s string, bitSize int)</td>
<td align="center">字符串转浮点数，bitSize指定了期望的接收类型</td>
</tr>
<tr>
<td align="center">func ParseInt(s string, base int, bitSize int)</td>
<td align="center">字符串转整数，base进制，bitSize指结果必须能无溢出赋值的整数类型</td>
</tr>
<tr>
<td align="center">func ParseUint(s string, base int, bitSize int)</td>
<td align="center">字符串转无符号整数</td>
</tr>
</tbody></table>
<h6 id="4-Go中的运算符"><a href="#4-Go中的运算符" class="headerlink" title="4. Go中的运算符"></a>4. Go中的运算符</h6><p><strong>算数运算符细节说明：</strong></p>
<ol>
<li>Golang的<code>++</code>和<code>--</code>只能在变量的后面，更加简洁统一</li>
<li><code>:=</code>是声明并赋值，会根据右边的表达式自动推断类型，<code>=</code>是赋值，需要显式指定类型</li>
</ol>
<p><strong>逻辑运算符细节说明：</strong></p>
<p>存在短路行为</p>
<p><strong>其他运算符说明：</strong></p>
<table>
<thead>
<tr>
<th align="center">运算符</th>
<th align="center">描述</th>
<th align="center">实例</th>
</tr>
</thead>
<tbody><tr>
<td align="center">&amp;</td>
<td align="center">返回变量存储地址</td>
<td align="center">&amp;a；给出a的实际地址</td>
</tr>
<tr>
<td align="center">*</td>
<td align="center">指针变量</td>
<td align="center">*a；是一个指针变量</td>
</tr>
</tbody></table>
<h6 id="5-键盘输入语句"><a href="#5-键盘输入语句" class="headerlink" title="5. 键盘输入语句"></a>5. 键盘输入语句</h6><p>导入fmt包，调用其中的<code>fmt.Scanln()</code>或者<code>fmt.Scanf()</code></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">var</span> name <span class="keyword">string</span></span><br><span class="line">	<span class="keyword">var</span> age <span class="keyword">int</span></span><br><span class="line">	fmt.Println(<span class="string">&quot;请输入姓名：&quot;</span>)</span><br><span class="line">	fmt.Scanln(&amp;name) <span class="comment">// 将键盘输入的字符串存储到name的地址中</span></span><br><span class="line">	fmt.Println(<span class="string">&quot;请输入年龄：&quot;</span>)</span><br><span class="line">	fmt.Scanln(&amp;age)</span><br><span class="line">	fmt.Println(name)</span><br><span class="line">	fmt.Println(age)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h6 id="6-Go中的进制表示方法"><a href="#6-Go中的进制表示方法" class="headerlink" title="6. Go中的进制表示方法"></a>6. Go中的进制表示方法</h6><table>
<thead>
<tr>
<th align="center">进制</th>
<th align="center">Golang表示</th>
</tr>
</thead>
<tbody><tr>
<td align="center">二进制</td>
<td align="center">采用<code>%b</code>将数字以二进制形式显示出来</td>
</tr>
<tr>
<td align="center">八进制</td>
<td align="center">以0开头会被认为是8进制</td>
</tr>
<tr>
<td align="center">十进制</td>
<td align="center">默认行为</td>
</tr>
<tr>
<td align="center">十六进制</td>
<td align="center">以<code>0x</code>或<code>0X</code>开头</td>
</tr>
</tbody></table>
<h4 id="Ⅱ、流程控制"><a href="#Ⅱ、流程控制" class="headerlink" title="Ⅱ、流程控制"></a>Ⅱ、流程控制</h4><h6 id="1-分支控制"><a href="#1-分支控制" class="headerlink" title="1. 分支控制"></a>1. 分支控制</h6><p>基本语法：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> 条件表达式&#123;</span><br><span class="line">	执行的代码块</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">	执行的代码块</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>细节注意：</p>
<ol>
<li><p>{}必须有</p>
</li>
<li><p>条件表达式不用（）包裹</p>
</li>
<li><p>条件表达式中如果有变量，变量的作用范围只在此次流程控制中有效</p>
</li>
<li><p><strong>条件表达式只能是一个表达式，不能是一个赋值语句，如<code>b := false</code>编译不通过</strong></p>
</li>
</ol>
<h6 id="2-switch分支结构"><a href="#2-switch分支结构" class="headerlink" title="2. switch分支结构"></a>2. switch分支结构</h6><p>基本语法：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> 表达式&#123;</span><br><span class="line">	<span class="keyword">case</span> 表达式<span class="number">1</span>,表达式<span class="number">2</span>,...:</span><br><span class="line">		语句块<span class="number">1</span></span><br><span class="line">	<span class="keyword">case</span> 表达式<span class="number">3</span>,表达式<span class="number">4</span>,...:</span><br><span class="line">		语句块<span class="number">2</span></span><br><span class="line">	...</span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">		语句块</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>细节注意：</p>
<ol>
<li>不需要break，默认跳出</li>
<li>一个case可以拥有多个表达式，使用<code>,</code>连接</li>
<li>case表达式的值的数据类型与表达式的数据类型一致，如果表达式是字面量，则不能重复</li>
<li>default不是必须的</li>
<li>switch后可以不带表达式，作为多个if-else分支使用</li>
<li>switch后可以定义或声明一个变量，分号结束，不推荐</li>
</ol>
<p>switch穿透-fallthrough：</p>
<p>如果在case语句后增加fallthrough，则会继续执行下一个case，这叫做switch穿透，默认只能穿透一层</p>
<h6 id="3-循环控制"><a href="#3-循环控制" class="headerlink" title="3. 循环控制"></a>3. 循环控制</h6><p>基本语法：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i:= <span class="number">1</span> ; i &lt;= <span class="number">10</span>; i++&#123;</span><br><span class="line">	表达式</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>细节说明：</p>
<ol>
<li>如果for后面没有变量初始化、循环判断条件、变量迭代，则此时的for相当于while</li>
<li>Golang提供for-range方式遍历字符串和数组，相当于java的for-each，语法如下</li>
</ol>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> index, val := <span class="keyword">range</span> str&#123;</span><br><span class="line">	fmt.Println(<span class="string">&quot;index = %d , val = %c \n&quot;</span> , index , val)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注：遍历字符串是按照字符遍历，而非字节遍历</p>
<ol start="3">
<li>可以使用标签指定从何处break和continue</li>
</ol>
<h6 id="4-跳转控制语句-goto"><a href="#4-跳转控制语句-goto" class="headerlink" title="4. 跳转控制语句-goto"></a>4. 跳转控制语句-goto</h6><p>基本语法：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">goto</span> label</span><br><span class="line">...</span><br><span class="line">label:statement</span><br></pre></td></tr></table></figure>

<p>细节注意：</p>
<ol>
<li>不建议使用，容易造成程序混乱</li>
<li>一般与条件语句配合使用</li>
</ol>
<h4 id="Ⅲ、函数、包和错误处理"><a href="#Ⅲ、函数、包和错误处理" class="headerlink" title="Ⅲ、函数、包和错误处理"></a>Ⅲ、函数、包和错误处理</h4><h6 id="1-函数"><a href="#1-函数" class="headerlink" title="1. 函数"></a>1. 函数</h6><blockquote>
<p>定义：完成某一功能的程序指令（语句）的集合，称为函数</p>
<p>Go中的函数分为：自定义函数、系统函数（可以查看Go编程手册）</p>
</blockquote>
<p>基本语法：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> 函数名（形参列表） （返回值类型列表）</span>&#123;</span><br><span class="line">	执行语句...</span><br><span class="line">	<span class="keyword">return</span> 返回值类型</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>细节说明：</p>
<ol>
<li>Go函数不支持重载</li>
<li>参数传递都是值传递，基本类型进行值拷贝，引用类型进行指针拷贝</li>
<li>在Go中，<strong>函数也是一种数据类型</strong>，可以赋值给一个变量，该变量就是一个函数类型的变量</li>
<li>Go支持自定义数据类型，使用type关键字</li>
<li>支持对函数返回值命名</li>
<li>使用<code>_</code>标识符，忽略返回值</li>
<li>支持可变参数</li>
</ol>
<p><strong>init函数：</strong></p>
<p><strong>每个源文件都可以包含一个init函数</strong>，该函数会在main函数执行前，被Go运行框架调用。通常用来做初始化操作</p>
<p>执行流程：全局变量定义 –&gt; init函数 –&gt; main函数</p>
<p><strong>匿名函数：</strong></p>
<p>如果某个函数只希望使用一次，可以考虑使用匿名函数，匿名函数也可以实现多次调用</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 只使用一次</span></span><br><span class="line">res := <span class="function"><span class="keyword">func</span> <span class="params">(n1 <span class="keyword">int</span> , n2 <span class="keyword">int</span>)</span> <span class="title">int</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> n1 + n2</span><br><span class="line">&#125;(n1 , n2)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 多次使用，a的类型就是函数类型 可以在函数中定义函数</span></span><br><span class="line">a := <span class="function"><span class="keyword">func</span> <span class="params">(n1 <span class="keyword">int</span> , n2 <span class="keyword">int</span>)</span> <span class="title">int</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> n1 - n2</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 全局匿名函数</span></span><br><span class="line"><span class="keyword">var</span>(</span><br><span class="line">    fun := <span class="function"><span class="keyword">func</span> <span class="params">(n1 <span class="keyword">int</span> , n2 <span class="keyword">int</span>)</span> <span class="title">int</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> n1 * n2</span><br><span class="line">    &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure>



<h6 id="2-包"><a href="#2-包" class="headerlink" title="2. 包"></a>2. 包</h6><blockquote>
<p>定义：创建不同的文件夹，存放程序文件。go以包的形式管理文件和项目目录结构，每一个文件都属于一个包。</p>
</blockquote>
<p>关键字：</p>
<table>
<thead>
<tr>
<th align="center">关键字</th>
<th align="center">含义</th>
</tr>
</thead>
<tbody><tr>
<td align="center">package</td>
<td align="center">指定当前go文件所属的包</td>
</tr>
<tr>
<td align="center">import</td>
<td align="center">导入需要的包</td>
</tr>
</tbody></table>
<p>使用细节：</p>
<ol>
<li>文件的包名一般与文件所在文件夹名一致，一般为小写字母</li>
<li>在import包时，路径从<code>&amp;GOPATH</code>下的<code>src</code>开始，不用带src，编译器从src下开始引入</li>
<li>包内函数大写开头代表public，小写开头代表private</li>
<li>访问其他包函数时，语法为：<code>包名.函数名</code></li>
<li>如果包名过长，Go支持给包取别名，取别名后，原来的包名无法使用</li>
<li>同一个包下不能有相同的函数名，会报重复定义的错误</li>
<li>如果要编译成一个可执行文件，就需要将包声明为main，即<code>package main</code>，这是语法规范。非main包的文件编译后会生成一个.a文件，作为库文件</li>
</ol>
<h6 id="3-闭包"><a href="#3-闭包" class="headerlink" title="3. 闭包"></a>3. 闭包</h6><blockquote>
<p>定义：闭包就是一个<strong>函数</strong>和<strong>其相关引用环境</strong>组合的一个整体（实体）</p>
</blockquote>
<p>实例：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">AddUpper</span><span class="params">()</span> <span class="title">func</span> <span class="params">(<span class="keyword">int</span>)</span> <span class="title">int</span></span>&#123;</span><br><span class="line">    <span class="comment">// 闭包begin</span></span><br><span class="line">    <span class="keyword">var</span> n <span class="keyword">int</span> = <span class="number">10</span></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">func</span> <span class="params">(x <span class="keyword">int</span>)</span> <span class="title">int</span></span>&#123;</span><br><span class="line">        n = n + x</span><br><span class="line">        <span class="keyword">return</span> n</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 闭包end</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>返回的一个匿名函数和外部的引用构成了一个闭包，可以简单的将一个闭包理解为一个类，其中函数为成员方法，变量为成员变量</p>
<p>搞清楚闭包的关键，就是分析出返回的函数和其引用到的变量</p>
<h6 id="4-defer"><a href="#4-defer" class="headerlink" title="4. defer"></a>4. defer</h6><blockquote>
<p>在函数中经常需要创建各种资源，为了在函数执行完毕后即时释放资源，Go提供了延时机制defer</p>
</blockquote>
<p>多个defer会采用defer栈的形式，可以将defer理解为finally</p>
<p>注意：defer将语句放入栈时，也会将相关的值拷贝同时入栈</p>
<h6 id="5-string中常用函数"><a href="#5-string中常用函数" class="headerlink" title="5. string中常用函数"></a>5. string中常用函数</h6><table>
<thead>
<tr>
<th align="center">函数</th>
<th align="center">作用</th>
</tr>
</thead>
<tbody><tr>
<td align="center">len（str）</td>
<td align="center">按字节统计字符串长度</td>
</tr>
<tr>
<td align="center">r := []rune(str)</td>
<td align="center">字符串遍历</td>
</tr>
<tr>
<td align="center">n,err := strconv.Atoi(“num”)</td>
<td align="center">字符串转整数</td>
</tr>
<tr>
<td align="center">str = strconv.Itoa(num)</td>
<td align="center">整数转字符串</td>
</tr>
<tr>
<td align="center">[]byte(“str”)</td>
<td align="center">字符串转字符数组</td>
</tr>
<tr>
<td align="center">string([]byte{ascll、ascll、ascll…})</td>
<td align="center">字符数组转字符串</td>
</tr>
<tr>
<td align="center">strconv.FormatInt(num , base)</td>
<td align="center">进制转换</td>
</tr>
<tr>
<td align="center">strings.Contains(“source” , “target” )</td>
<td align="center">查找子串是否在指定字符串中</td>
</tr>
<tr>
<td align="center">strings.Count(“source” , “target”)</td>
<td align="center">统计一个字符串中有几个指定的子串</td>
</tr>
<tr>
<td align="center">strings.EqualFold(“str1” , “str2”)</td>
<td align="center">不区分大小写比较两个字符串（==区分大小写）</td>
</tr>
<tr>
<td align="center">strings.Index(“source” ， “target”)</td>
<td align="center">返回子串在字符串中第一次出现的index值，没有返回-1</td>
</tr>
<tr>
<td align="center">strings.Join(s, “str”)</td>
<td align="center">将string数组的元素按照指定的字符串拼接起来</td>
</tr>
<tr>
<td align="center">strings.LastIndex(“str1” , “str2”)</td>
<td align="center">返回子串在字符串中最后一次出现的index值，没有返回-1</td>
</tr>
<tr>
<td align="center">strings.Replace(str , sourceStr , targetStr , n)</td>
<td align="center">将字符串中指定的子串替换为另一个子串，n指定次数，n=-1代表全部替换</td>
</tr>
<tr>
<td align="center">strings.Split(str , s)</td>
<td align="center">按照规定的字符将字符串变为字符串数组</td>
</tr>
<tr>
<td align="center">strings.ToLower（str）/strings.ToUpper(str)</td>
<td align="center">转大小写</td>
</tr>
<tr>
<td align="center">strings.TrimSpace(str)</td>
<td align="center">去掉两端空格</td>
</tr>
<tr>
<td align="center">strings.Trim(str , s)</td>
<td align="center">去掉两端s字符串</td>
</tr>
<tr>
<td align="center">strings.TrimLeft(str , s)</td>
<td align="center">去掉左边指定字符</td>
</tr>
<tr>
<td align="center">strings.TrimRight(str , s)</td>
<td align="center">去掉右边指定字符</td>
</tr>
<tr>
<td align="center">strings.HasPrefix(str , beginStr)</td>
<td align="center">判断是否以指定字符串开头</td>
</tr>
<tr>
<td align="center">strings.HasSuffix(str , endStr)</td>
<td align="center">判断是否以指定字符串结尾</td>
</tr>
</tbody></table>
<h6 id="6-时间和日期相关函数"><a href="#6-时间和日期相关函数" class="headerlink" title="6. 时间和日期相关函数"></a>6. 时间和日期相关函数</h6><p>时间和日期相关函数需要导入time包</p>
<p>time.Time类型用于表示时间</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>  &#123;</span><br><span class="line">    now := time.Now()</span><br><span class="line">    fmt.Printf(<span class="string">&quot;now=%v now type = %T\n&quot;</span>,now,now)    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以使用<code>time.Format（“Time”）</code>来格式化输出</p>
<p>时间常量：</p>
<table>
<thead>
<tr>
<th align="center">常量</th>
<th align="center">含义</th>
</tr>
</thead>
<tbody><tr>
<td align="center">Nanosecond</td>
<td align="center">1纳秒</td>
</tr>
<tr>
<td align="center">Microsecond</td>
<td align="center">1微妙</td>
</tr>
<tr>
<td align="center">Millisecond</td>
<td align="center">1毫秒</td>
</tr>
<tr>
<td align="center">Second</td>
<td align="center">1秒</td>
</tr>
<tr>
<td align="center">Minute</td>
<td align="center">1分钟</td>
</tr>
<tr>
<td align="center">Hour</td>
<td align="center">1小时</td>
</tr>
</tbody></table>
<p>两个获得时间戳的方法：</p>
<p>time.now.Unix()</p>
<p>time.now.UnixNano()</p>
<h6 id="7-Golang的内置函数"><a href="#7-Golang的内置函数" class="headerlink" title="7. Golang的内置函数"></a>7. Golang的内置函数</h6><table>
<thead>
<tr>
<th align="center">函数名</th>
<th align="center">功能</th>
</tr>
</thead>
<tbody><tr>
<td align="center">len()</td>
<td align="center">len 用于返回某个类型的长度或数量（字符串、数组、切片、map 和管道）</td>
</tr>
<tr>
<td align="center">cap()</td>
<td align="center">cap 返回某个类型的最大容量（只能用于切片和 map）</td>
</tr>
<tr>
<td align="center">new()</td>
<td align="center">new 用于值类型和用户定义的类型，如自定义结构，返回地址指针</td>
</tr>
<tr>
<td align="center">make()</td>
<td align="center">make 用于内置引用类型（切片、map 和管道），返回地址指针</td>
</tr>
</tbody></table>
<h6 id="8-Golang的错误处理"><a href="#8-Golang的错误处理" class="headerlink" title="8. Golang的错误处理"></a>8. Golang的错误处理</h6><blockquote>
<p>为了简洁优雅，Go语言不支持try…catch…finally这种处理方式，其处理方式为：defer、panic、recover</p>
<p>这三个关键字的描述如下</p>
</blockquote>
<table>
<thead>
<tr>
<th align="center">关键字</th>
<th align="center">作用</th>
</tr>
</thead>
<tbody><tr>
<td align="center">defer</td>
<td align="center">延迟执行</td>
</tr>
<tr>
<td align="center">panic</td>
<td align="center">抛出异常</td>
</tr>
<tr>
<td align="center">recover</td>
<td align="center">捕获异常</td>
</tr>
</tbody></table>
<p>示例</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        err := <span class="built_in">recover</span>() <span class="comment">// recover()为内置函数，可以捕获到异常</span></span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span>&#123;</span><br><span class="line">            fmt.Println(<span class="string">&quot;err = &quot;</span> , err)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;() <span class="comment">// 匿名函数</span></span><br><span class="line">    res := <span class="number">10</span> / <span class="number">0</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;res = &quot;</span> , res)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>自定义错误：使用errors.New 和 panic 内置函数</p>
<p>示例</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">readConf</span><span class="params">(path <span class="keyword">string</span>)</span> <span class="title">err</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> name == <span class="string">&quot;config.ini&quot;</span>&#123;</span><br><span class="line">		...</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">	&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">		<span class="comment">// 返回错误</span></span><br><span class="line">		<span class="keyword">return</span> errors.New(<span class="string">&quot;读取文件错误&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    err := readConf(<span class="string">&quot;config.xml&quot;</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span>&#123;</span><br><span class="line">        <span class="built_in">panic</span>(err) <span class="comment">// 输出错误并终止程序</span></span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="三、数组、切片和Map"><a href="#三、数组、切片和Map" class="headerlink" title="三、数组、切片和Map"></a>三、数组、切片和Map</h2><h4 id="Ⅰ、数组"><a href="#Ⅰ、数组" class="headerlink" title="Ⅰ、数组"></a>Ⅰ、数组</h4><blockquote>
<p>数组可以存放多个同一类型数据，在Go中，数组是值类型</p>
</blockquote>
<h6 id="1-定义与初始化"><a href="#1-定义与初始化" class="headerlink" title="1. 定义与初始化"></a>1. 定义与初始化</h6><p>var 数组名 [数组大小]数据类型</p>
<p><strong>示例</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> nums [<span class="number">10</span>]<span class="keyword">int</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span> ; i &lt; <span class="built_in">len</span>(nums) ; i++&#123;</span><br><span class="line">	nums[i] = i</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// for-range遍历</span></span><br><span class="line">val := <span class="number">1</span></span><br><span class="line"><span class="keyword">for</span> index , value := <span class="keyword">range</span> nums&#123; <span class="comment">// 如果不关心下标，则下标可用_忽略</span></span><br><span class="line">    nums[index] = val++</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在内存中，数组名的地址就是数组第一个元素的地址，即数组的首地址，数组占用连续的一段内存</p>
<h6 id="2-细节说明"><a href="#2-细节说明" class="headerlink" title="2. 细节说明:"></a>2. 细节说明:</h6><ol>
<li>定长不可变</li>
<li>数组中元素的数据类型固定，不可混用</li>
<li>数组创建后如果没有显式赋值，则会有默认值</li>
<li>Go的数组属于值类型，在传递时会进行值拷贝，所以数组之间不会相互影响。如果想修改原来的数组，则需要传递指针</li>
</ol>
<h4 id="Ⅱ、切片"><a href="#Ⅱ、切片" class="headerlink" title="Ⅱ、切片"></a>Ⅱ、切片</h4><blockquote>
<p>切片通过对底层数组进行抽象，并且提供了相关的方法，来达到了动态数组的效果。一个切片有三个字段：地址指针、长度和容量。个人看来，可以将切片理解为SQL中的视图</p>
</blockquote>
<h6 id="1-切片的创建和初始化"><a href="#1-切片的创建和初始化" class="headerlink" title="1. 切片的创建和初始化"></a>1. 切片的创建和初始化</h6><p>方式一：通过make</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">slice := <span class="built_in">make</span>([]<span class="keyword">int</span> , <span class="built_in">len</span> , <span class="built_in">cap</span>) <span class="comment">// 创建一个长度和容量为指定值的整型切片，如果不指定cap，则cap=len</span></span><br></pre></td></tr></table></figure>

<p>注：len &lt;= cap，cap即底层数组的长度</p>
<p>方式二：通过字面量</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">myNum := []<span class="keyword">int</span>&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125; <span class="comment">// 创建长度和容量都是4的切片</span></span><br><span class="line">myStr ：= []<span class="keyword">string</span>&#123;<span class="number">99</span> : <span class="string">&quot;&quot;</span>&#125; <span class="comment">// 使用空字符串初始化第100个元素</span></span><br></pre></td></tr></table></figure>

<p>注：[]中有数字是数组声明，没数字是切片声明。在不初始化时会创建一个nil切片</p>
<h6 id="2-切片的切片"><a href="#2-切片的切片" class="headerlink" title="2. 切片的切片"></a>2. 切片的切片</h6><p>语法：<code>slice[i : j]</code>或者<code>slice[i : j : k]</code>，会创造一个【i ， j）的切片，长度为j - i ， 容量为 k - i，如果没有指定k，则k为原切片的长度。</p>
<p>切片的切片和切片共享同一个底层数组</p>
<h6 id="3-切片扩容"><a href="#3-切片扩容" class="headerlink" title="3. 切片扩容"></a>3. 切片扩容</h6><p>语法：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">myNum := slice[<span class="number">1</span>:<span class="number">3</span>]</span><br><span class="line">myNum := myNum.<span class="built_in">append</span>(myNum , <span class="number">60</span>)</span><br></pre></td></tr></table></figure>

<p>在切片的后面追加元素，即改变了底层数组index=3位置的值，由于底层数组长度还够，所以不会改变容量。</p>
<p>如果底层数组用尽，则在切片容量小于1000时成倍扩容，超过1000，增长因子为1.25</p>
<h6 id="4-切片遍历"><a href="#4-切片遍历" class="headerlink" title="4. 切片遍历"></a>4. 切片遍历</h6><p>语法：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> index , value := <span class="keyword">range</span> slice&#123;</span><br><span class="line">	fmt.Println(<span class="string">&quot;index: %d , value : %d\n&quot;</span> , index , value)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注：切片的遍历返回的是每个元素的副本，对其修改不能改变原底层数组</p>
<h6 id="5-string的特殊之处"><a href="#5-string的特殊之处" class="headerlink" title="5. string的特殊之处"></a>5. string的特殊之处</h6><p>string底层是一个byte数组，是不可变的，所以也可以对其切片。</p>
<p>由于string不可变，所以不可以通过<code>str[1] = &#39;z&#39;</code>这样的形式来更改元素，如果想要修改字符串，可以先将string转为byte数组</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">arr := []<span class="keyword">byte</span>(str)</span><br><span class="line">arr[index] = value</span><br><span class="line">str = <span class="keyword">string</span>(arr)</span><br></pre></td></tr></table></figure>

<p>细节：中文乱码问题（byte是字节处理，而一个汉字是三个字节，故出现乱码），解决方法是将string转为[]rune即可，[]rune是按字符处理</p>
<h4 id="Ⅲ、Map"><a href="#Ⅲ、Map" class="headerlink" title="Ⅲ、Map"></a>Ⅲ、Map</h4><blockquote>
<p>map是k-v对的数据结构，类似java的集合，使用频率很高。</p>
</blockquote>
<h6 id="1-基本语法"><a href="#1-基本语法" class="headerlink" title="1. 基本语法"></a>1. 基本语法</h6><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 声明</span></span><br><span class="line"><span class="keyword">var</span> 变量名 <span class="keyword">map</span>[keytype]valuetype</span><br><span class="line"><span class="comment">// 分配空间</span></span><br><span class="line">变量名 = <span class="built_in">make</span>(<span class="keyword">map</span>[keytype]valuetype , size)</span><br><span class="line"><span class="comment">// 使用</span></span><br><span class="line">变量名[key] = value</span><br><span class="line"></span><br><span class="line"><span class="comment">// 或者可以在声明时就通过字面量创建</span></span><br><span class="line"><span class="keyword">map</span> := <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>&#123;</span><br><span class="line">    <span class="string">&quot;176&quot;</span>:<span class="string">&quot;wh&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>key的类型选择：</p>
<p>bool、int、string、指针、channer，和包含这几个类型的接口、结构体、数组，通常为<strong>int</strong>和<strong>string</strong></p>
<p>slice、map和function不可以，这几个无法通过==判断</p>
<p>声明不会分配内存，需要后续使用make分配内存后赋值和使用</p>
<h6 id="2-增删改查"><a href="#2-增删改查" class="headerlink" title="2. 增删改查"></a>2. 增删改查</h6><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 增</span></span><br><span class="line"><span class="keyword">map</span>[<span class="string">&quot;177&quot;</span>] = <span class="string">&quot;ls&quot;</span></span><br><span class="line"><span class="comment">// 删</span></span><br><span class="line"><span class="built_in">delete</span>(<span class="keyword">map</span> , <span class="string">&quot;176&quot;</span>)</span><br><span class="line"><span class="comment">// 改</span></span><br><span class="line"><span class="keyword">map</span>[<span class="string">&quot;176&quot;</span>] = <span class="string">&quot;ww&quot;</span></span><br><span class="line"><span class="comment">// 查</span></span><br><span class="line">v := <span class="keyword">map</span>[<span class="string">&quot;176&quot;</span>]</span><br></pre></td></tr></table></figure>

<h6 id="3-map遍历"><a href="#3-map遍历" class="headerlink" title="3. map遍历"></a>3. map遍历</h6><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> k , v := <span class="keyword">range</span> <span class="keyword">map</span>&#123;</span><br><span class="line">	fmt.Printf(<span class="string">&quot;k = %v , v = %v&quot;</span> , k , v)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意：遍历的所有v共用一块内存，只是这个内存中的元素在迭代</p>
<h6 id="4-map细节"><a href="#4-map细节" class="headerlink" title="4. map细节"></a>4. map细节</h6><ol>
<li>map参数传递时传递的是指针</li>
<li>map会自动扩容，不会发生panic</li>
<li>map的value常常用struct，起到类似对象的作用</li>
<li>map如今是有序的</li>
</ol>
<h2 id="四、面向对象编程"><a href="#四、面向对象编程" class="headerlink" title="四、面向对象编程"></a>四、面向对象编程</h2><blockquote>
<p>go中的面向对象个人感觉是通过结构体来完成的，而且go中的结构体是值类型</p>
</blockquote>
<h4 id="Ⅰ、基本语法"><a href="#Ⅰ、基本语法" class="headerlink" title="Ⅰ、基本语法"></a>Ⅰ、基本语法</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> student <span class="keyword">struct</span>&#123; <span class="comment">// 类似于类 , 通过大小写来决定private还是public</span></span><br><span class="line">    id <span class="keyword">int</span></span><br><span class="line">	name <span class="keyword">string</span></span><br><span class="line">    age <span class="keyword">int</span></span><br><span class="line">&#125; <span class="comment">// 这是一个公有的类，类中的所有字段都是私有的</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Student)</span> <span class="title">init</span><span class="params">(id <span class="keyword">int</span> , name <span class="keyword">string</span> , age <span class="keyword">int</span>)</span></span>&#123; <span class="comment">// 定义“构造方法”</span></span><br><span class="line">    s.id = id</span><br><span class="line">    s.name = name</span><br><span class="line">    s.age = age</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Ⅱ、创建结构体的四种方式："><a href="#Ⅱ、创建结构体的四种方式：" class="headerlink" title="Ⅱ、创建结构体的四种方式："></a>Ⅱ、创建结构体的四种方式：</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Person <span class="keyword">struct</span>&#123;</span><br><span class="line">    name <span class="keyword">string</span></span><br><span class="line">    age <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 方式一</span></span><br><span class="line"><span class="keyword">var</span> p Person = Person&#123;&#125;</span><br><span class="line"><span class="comment">// 方式二</span></span><br><span class="line">p := Person&#123;<span class="string">&quot;wuhao&quot;</span> , <span class="number">21</span>&#125;</span><br><span class="line"><span class="comment">// 方式三</span></span><br><span class="line"><span class="keyword">var</span> p *Person = <span class="built_in">new</span>(Person)</span><br><span class="line"><span class="comment">// 方式四</span></span><br><span class="line"><span class="keyword">var</span> p *Person = &amp;Person&#123;&#125;</span><br></pre></td></tr></table></figure>

<p><em>显然，new关键字返回的是一个地址</em></p>
<h4 id="Ⅲ、面向对象的特性"><a href="#Ⅲ、面向对象的特性" class="headerlink" title="Ⅲ、面向对象的特性"></a>Ⅲ、面向对象的特性</h4><h6 id="1-封装："><a href="#1-封装：" class="headerlink" title="1. 封装："></a>1. 封装：</h6><p>通过大小写实现</p>
<h6 id="2-继承："><a href="#2-继承：" class="headerlink" title="2. 继承："></a>2. 继承：</h6><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Person <span class="keyword">struct</span>&#123;</span><br><span class="line">	name <span class="keyword">string</span></span><br><span class="line">	age <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Employee <span class="keyword">struct</span>&#123;</span><br><span class="line">	Person</span><br><span class="line">	company <span class="keyword">string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>继承的实现不依赖关键字，只需要在被继承类中声明继承类即可，显然，可以多继承</p>
<p>当调用父类的方法或者字段是，使用<code>s.Person</code>获得父类</p>
<p>显然，可以多重继承</p>
<h6 id="3-多态："><a href="#3-多态：" class="headerlink" title="3. 多态："></a>3. 多态：</h6><blockquote>
<p>基类指针可以指向任意派生类的对象，并在运行时动态绑定最终调用的方法，这就是多态。（与java相同）</p>
</blockquote>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Animal <span class="keyword">interface</span>&#123; <span class="comment">// 接口，定义未实现的方法</span></span><br><span class="line">	Shout()</span><br><span class="line">	Eat()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Dog <span class="keyword">struct</span>&#123; <span class="comment">// 定义一个结构体，没有字段</span></span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(dog Dog)</span> <span class="title">Move</span><span class="params">()</span></span>&#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;四条腿走路&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(dog Dog)</span> <span class="title">Shout</span><span class="params">()</span></span>&#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;汪汪&quot;</span>)</span><br><span class="line">&#125; <span class="comment">// 当实现了接口中的抽象方法，默认实现了接口</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Brid <span class="keyword">struct</span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(brid Brid)</span> <span class="title">Move</span></span>&#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;飞着走路&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(brid Brid)</span> <span class="title">Shout</span></span>&#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;啾啾&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">var</span> animal Animal</span><br><span class="line">    animal = Dog&#123;&#125; <span class="comment">// ok</span></span><br><span class="line">    animal = Brid&#123;&#125; <span class="comment">// ok</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Ⅳ、细节说明："><a href="#Ⅳ、细节说明：" class="headerlink" title="Ⅳ、细节说明："></a>Ⅳ、细节说明：</h4><h6 id="1-结构体"><a href="#1-结构体" class="headerlink" title="1. 结构体"></a>1. 结构体</h6><ol>
<li>结构体中的字段在内存中是连续存放的</li>
<li>结构体是自定义类型，在进行类型转换时需要完全相同的字段</li>
<li>结构体可以使用type取别名，但是Golang认为是新的数据类型，与原类型之间可以相互转换</li>
<li>结构体的每个字段上可以加一个tag，该tag可以通过反射机制获取。常见使用场景是序列化和反序列化</li>
</ol>
<h6 id="2-方法"><a href="#2-方法" class="headerlink" title="2. 方法"></a>2. 方法</h6><ol>
<li>方法是作用在指定的数据类型上的，所以自定义类型都可以有方法</li>
<li>方法的访问范围控制与函数相同，首字母大写可以访问，小写不可以</li>
<li>如果实现了String()这个方法，则fmt.Println()默认会调用这个变量的该方法，相当于java中Object的toString方法重载</li>
<li>方法传递机制取决于相关数据类型的传递机制，如结构体就是值传递</li>
<li>如果想要引用传递，则请传递指针</li>
</ol>
<h6 id="3-方法和函数的区别"><a href="#3-方法和函数的区别" class="headerlink" title="3. 方法和函数的区别"></a>3. 方法和函数的区别</h6><p>函数的形参与实参一定要严格对应，结构体与指针不能相互转换</p>
<p>方法的形参和实参数据类型可以相互转换，如方法要求一个结构体时，可以传递给一个指针，反之亦然。（编译器做了底部优化）</p>
<h2 id="五、文件流"><a href="#五、文件流" class="headerlink" title="五、文件流"></a>五、文件流</h2><blockquote>
<p>go的文件流与java类似，建立在一个文件对象上，这里的文件对象实际上是一个指针，所以又叫文件指针或者文件句柄。</p>
</blockquote>
<h4 id="Ⅰ、获取文件"><a href="#Ⅰ、获取文件" class="headerlink" title="Ⅰ、获取文件"></a>Ⅰ、获取文件</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">file , err = os.Open(path <span class="keyword">string</span>) <span class="comment">// 打开文件流</span></span><br><span class="line"><span class="keyword">defer</span> file.Close() <span class="comment">// 确保关闭文件流</span></span><br></pre></td></tr></table></figure>

<p>两个返回值，文件指针和错误信息</p>
<h4 id="Ⅱ、包装流"><a href="#Ⅱ、包装流" class="headerlink" title="Ⅱ、包装流"></a>Ⅱ、包装流</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">reader := bufio.NewReader(file) <span class="comment">// 缓冲流</span></span><br><span class="line"><span class="keyword">for</span>&#123;</span><br><span class="line">    str , err := reader.ReadString(<span class="string">&#x27;\n&#x27;</span>) <span class="comment">// 以行为单位进行文件读取</span></span><br><span class="line">    fmt.Println(str)</span><br><span class="line">    <span class="keyword">if</span> err == io.EOF&#123; <span class="comment">// 读到文件末尾</span></span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">content , err := ioutil.ReadFile(file) <span class="comment">// 一次性将文件读到内存中</span></span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span>&#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;err:&quot;</span> , err)</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(<span class="keyword">string</span>(content))</span><br></pre></td></tr></table></figure>

<h6 id="Ⅲ、写文件"><a href="#Ⅲ、写文件" class="headerlink" title="Ⅲ、写文件"></a>Ⅲ、写文件</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>


      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2020/07/18/Go%E8%AF%AD%E8%A8%80/" data-id="ckifb2s4u000v6jnr3wha9wfr" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2020/07/18/JavaSE%E4%B9%8B%E5%8F%8D%E5%B0%84/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          框架核心
        
      </div>
    </a>
  
  
    <a href="/2020/07/14/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">中间件</div>
    </a>
  
</nav>

  
</article>

</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/12/">December 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/07/">July 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/06/">June 2020</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2020/12/07/cpu%E9%A3%99%E9%AB%98%E6%8E%92%E6%9F%A5/">(no title)</a>
          </li>
        
          <li>
            <a href="/2020/12/04/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B4%A2%E5%BC%95/">(no title)</a>
          </li>
        
          <li>
            <a href="/2020/07/29/%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F/">高并发相关技术</a>
          </li>
        
          <li>
            <a href="/2020/07/27/%E6%95%B0%E6%8D%AE%E5%BA%8F%E5%88%97%E5%8C%96%E6%96%B9%E6%A1%88/">(no title)</a>
          </li>
        
          <li>
            <a href="/2020/07/21/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/">(no title)</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2020 John Doe<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  
<link rel="stylesheet" href="/fancybox/jquery.fancybox.css">

  
<script src="/fancybox/jquery.fancybox.pack.js"></script>




<script src="/js/script.js"></script>




  </div>
</body>
</html>